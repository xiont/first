<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- TemplateBeginEditable name="doctitle" -->
<title>无标题文档</title>
<!-- TemplateEndEditable -->
<!-- TemplateBeginEditable name="head" -->
<!-- TemplateEndEditable -->


<style type="text/css">
<!--
body {
	font: 100%/1.4 Verdana, Arial, Helvetica, sans-serif;
	background-color:#3FF;
	margin: 0;
	padding: 0;
	color: #000;
}

/* ~~ 元素/标签选择器 ~~ */
ul, ol, dl { /* 由于浏览器之间的差异，最佳做法是在列表中将填充和边距都设置为零。为了保持一致，您可以在此处指定需要的数值，也可以在列表所包含的列表项（LI、DT 和 DD）中指定需要的数值。请注意，除非编写一个更为具体的选择器，否则您在此处进行的设置将会层叠到 .nav 列表。 */
	padding: 0;
	margin: 0;
}
h1, h2, h3, h4, h5, h6, p {
	margin-top: 0;	 /* 删除上边距可以解决边距会超出其包含的 div 的问题。剩余的下边距可以使 div 与后面的任何元素保持一定距离。 */
	padding-right: 15px;
	padding-left: 15px; /* 向 div 内的元素侧边（而不是 div 自身）添加填充可避免使用任何方框模型数学。此外，也可将具有侧边填充的嵌套 div 用作替代方法。 */
}
a img { /* 此选择器将删除某些浏览器中显示在图像周围的默认蓝色边框（当该图像包含在链接中时） */
	border: none;
}

/* ~~ 站点链接的样式必须保持此顺序，包括用于创建悬停效果的选择器组在内。 ~~ */
a:link {
	color:#FFF;
	text-decoration: underline; /* 除非将链接设置成极为独特的外观样式，否则最好提供下划线，以便可从视觉上快速识别 */
}
a:visited {
	color: #FFF;
	text-decoration: underline;
}
a:hover, a:active, a:focus { /* 此组选择器将为键盘导航者提供与鼠标使用者相同的悬停体验。 */
	text-decoration: none;
}

/* ~~ 此固定宽度容器包含所有其它 div ~~ */
.container {
	width: 960px;
	background-color: #CFF;
	margin: 0 auto; /* 侧边的自动值与宽度结合使用，可以将布局居中对齐 */
}

/* ~~ 标题未指定宽度。它将扩展到布局的完整宽度。标题包含一个图像占位符，该占位符应替换为您自己的链接徽标。 ~~ */
.header {
	background-color: #FFF;
}
.axis path,
	.axis line{
		fill: none;
		stroke: #F36;
		shape-rendering: crispEdges;
	}

	.axis text {
		font-family: sans-serif;
		font-size: 10px;
	}

	.MyRect {
		fill: steelblue;
	}

	.MyText {
		fill: #003;
		text-anchor: middle;
		font-family:楷体, sans-serif;
		font-size: 18px;
	}
	.MyText2 {
		fill: black;
		text-anchor: middle;
		font-family:黑体, sans-serif;
		font-weight:bold;
		font-size: 25px;
	}
	.MyCircle
	{
		fill: red;
		filter:alpha(opacity=50);
		-moz-opacity:0.5;  
        -khtml-opacity: 0.5; 
        opacity: 0.7;  
		}
	.MyCircle2
	{
		fill: blue;
		filter:alpha(opacity=50);
		-moz-opacity:0.5;  
        -khtml-opacity: 0.5;  
        opacity: 0.7;  
		}
	.MyCircle3
	{
		fill: yellow;
		filter:alpha(opacity=50);
		-moz-opacity:0.5;  
        -khtml-opacity: 0.5;  
        opacity: 0.7;  
		}


/* ~~ 以下是此布局的列。 ~~ 

1) 填充只会放置于 div 的顶部和/或底部。此 div 中的元素侧边会有填充。这样，您可以避免使用任何“方框模型数学”。请注意，如果向 div 自身添加任何侧边填充或边框，这些侧边填充或边框将与您定义的宽度相加，得出 *总计* 宽度。您也可以选择删除 div 中的元素的填充，并在该元素中另外放置一个没有任何宽度但具有设计所需填充的 div。

2) 由于这些列均为浮动列，因此未对其指定边距。如果必须添加边距，请避免在浮动方向一侧放置边距（例如：div 中的右边距设置为向右浮动）。在很多情况下，都可以改用填充。对于必须打破此规则的 div，应向该 div 的规则中添加“display:inline”声明，以控制某些版本的 Internet Explorer 会使边距翻倍的错误。

3) 由于可以在一个文档中多次使用类（并且一个元素可以应用多个类），因此已向这些列分配类名，而不是 ID。例如，必要时可堆叠两个侧栏 div。您可以根据个人偏好将这些名称轻松地改为 ID，前提是仅对每个文档使用一次。

4) 如果您更喜欢在右侧（而不是左侧）进行导航，只需使这些列向相反方向浮动（全部向右，而非全部向左），它们将按相反顺序显示。您无需在 HTML 源文件中移动 div。

*/
.sidebar1 {
	float: left;
	width: 180px;
	background-color: #000;
	padding-bottom: 10px;
}
.content {

	padding: 10px 0;
	width: 600px;
	float: left;
}
.sidebar2 {
	float: left;
	width: 180px;
	background-color: #000;
	padding: 10px 0;
}

/* ~~ 此分组的选择器为 .content 区域中的列表提供了空间 ~~ */
.content ul, .content ol { 
	padding: 0 15px 15px 40px; /* 此填充反映上述标题和段落规则中的右填充。填充放置于下方可用于间隔列表中其它元素，置于左侧可用于创建缩进。您可以根据需要进行调整。 */
}

/* ~~ 导航列表样式（如果选择使用预先创建的 Spry 等弹出菜单，则可以删除此样式） ~~ */
ul.nav {
	list-style: none; /* 这将删除列表标记 */
	border-top: 1px solid #FFF; /* 这将为链接创建上边框 – 使用下边框将所有其它项放置在 LI 中 */
	margin-bottom: 15px; /* 这将在下面内容的导航之间创建间距 */
}
ul.nav li {
	border-bottom: 1px solid #FFF; /* 这将创建按钮间隔 */
}
ul.nav a, ul.nav a:visited { /* 对这些选择器进行分组可确保链接即使在访问之后也能保持其按钮外观 */
	padding: 5px 5px 5px 15px;
	display: block; /* 这将为锚记赋予块属性，使其填满包含它的整个 LI。这样，整个区域都可以响应鼠标单击操作。 */
	width: 160px;  /*此宽度使整个按钮在 IE6 中可单击。如果您不需要支持 IE6，可以删除它。请用侧栏容器的宽度减去此链接的填充来计算正确的宽度。 */
	text-decoration: none;
	background-color: #000;
}
ul.nav a:hover, ul.nav a:active, ul.nav a:focus { /* 这将更改鼠标和键盘导航的背景和文本颜色 */
	background-color: #000;
	color: #FFF;
}

/* ~~ 脚注样式 ~~ */
.footer {
	padding: 10px 0;
	background-color: #000;
	position: relative;/* 这可以使 IE6 hasLayout 以正确方式进行清除 */
	clear: both; /* 此清除属性强制 .container 了解列的结束位置以及包含列的位置 */
}

/* ~~ 其它浮动/清除类 ~~ */
.fltrt {  /* 此类可用于在页面中使元素向右浮动。浮动元素必须位于其在页面上的相邻元素之前。 */
	float: right;
	margin-left: 8px;
}
.fltlft { /* 此类可用于在页面中使元素向左浮动。浮动元素必须位于其在页面上的相邻元素之前。 */
	float: left;
	margin-right: 8px;
}
.clearfloat { /* 如果从 .container 中删除或移出了 .footer，则可以将此类放置在 <br /> 或空 div 中，作为 .container 内最后一个浮动 div 之后的最终元素 */
	clear:both;
	height:0;
	font-size: 1px;
	line-height: 0px;
}


-->
</style>
<style>
	.axis path,
	.axis line{
		fill: none;
		stroke: #F36;
		shape-rendering: crispEdges;
	}

	.axis text {
		font-family: sans-serif;
		font-size: 10px;
	}

	.MyRect {
		fill: steelblue;
	}

	.MyText {
		fill: #003;
		text-anchor: middle;
		font-family:楷体, sans-serif;
		font-size: 18px;
	}
	.MyText2 {
		fill: black;
		text-anchor: middle;
		font-family:黑体, sans-serif;
		font-weight:bold;
		font-size: 25px;
	}
	.MyCircle
	{
		fill: red;
		filter:alpha(opacity=50);
		-moz-opacity:0.5;  
        -khtml-opacity: 0.5; 
        opacity: 0.7;  
		}
	.MyCircle2
	{
		fill: blue;
		filter:alpha(opacity=50);
		-moz-opacity:0.5;  
        -khtml-opacity: 0.5;  
        opacity: 0.7;  
		}
	.MyCircle3
	{
		fill: yellow;
		filter:alpha(opacity=50);
		-moz-opacity:0.5;  
        -khtml-opacity: 0.5;  
        opacity: 0.7;  
		}
</style>
</head>

<body>

<div class="container">
  <div class="header"><a href="#"><img src="bear.jpg" alt="在此处插入徽标" name="Insert_logo" width="180" height="90" id="Insert_logo" style="background-color: #CFF; display:block;" /></a> 
    <!-- end .header --></div>
  <div class="sidebar1">
    <ul class="nav">
      <li id="start"><a href="./index.html">随我开始</a></li>
     <li id="layout"><a href="./pages/layout/index.html">试试布局</a></li>
     <li id="map"><a href="./pages/map/index.html">玩玩地图</a></li>
     <li id="research"><a href="./pages/research/index.html">研究心得</a></li>
     <li id="movie"><a href="./pages/movie/index.html">看看视频</a></li>
     <li id="bbs"><a href="http://bbs.decembercafe.org/">论坛说说</a></li>
    </ul>
    <p style="background:#000;color:#FFF">D3.js 是基于数据操作文档的 JavaScript 库，通过 HTML、SVG 和 CSS 赋予数据以生命。D3 集强力的可视化组件与数据驱动型的 DOM 操作手法于一身，能最大限度地引出现代浏览器的性能，而不必束缚于特定的框架。</p>
    <p style="background:#000;color:#FFF">如果您想了解更多请访问上述链接。</p>
    <!-- end .sidebar1 --></div>
  <div class="content">
    <h1>一、可视化展现</h1>
    <p>
    <script src="d3.min.js" charset="utf-8"></script>
<object width="32" height="32">
</object>
<script>
//画布大小
var width = 600;
var height = 380;
//在body元素中添加一个画
var svg = d3.select("body")
			.select(".content")
			.select("p")
			.append("svg")
			.attr("width",width)
			.attr("height",height);

			
//x的比例尺
var xScale=d3.scale.linear()
	.domain([0,12])
	.range([0,500]);
var yScale=d3.scale.linear()
	.domain([0,0])
	.range([0,300]);
//定义x轴
var xAxis = d3.svg.axis()
	.scale(xScale)
	.orient("bottom");
//定义y 轴
var yAxis = d3.svg.axis()
	.scale(yScale)
	.orient("left");
//添加x轴
svg.append("g")
  .attr("class","axis")
  .attr("transform","translate(50,90)")
  .call(xAxis); 
svg.append("g")
  .attr("class","axis")
  .attr("transform","translate(50,190)")
  .call(xAxis); 
 svg.append("g")
  .attr("class","axis")
  .attr("transform","translate(50,290)")
  .call(xAxis); 
  
        
//添加y轴
svg.append("g")
  .attr("class","axis")
  .attr("transform","translate(50,40)")
  .call(yAxis);
  
var dataset1=[25,57.3,78.4,66.3,99,12];
var dataset2=[34,67.3,38.4,86.3,29,99];
var dataset3=[98,17.3,43.6,36.3,95.3,62];
var data1time=[1,3,4,7,9,12];
var data2time=[2,3,4,5,9,11];
var data3time=[1,5,7,8,9,10];
var data1=new Array(6);
for(var i=0;i<6;i++)
   {data1[i]=Math.ceil(dataset1[i]/20)}
var index = [1, 2, 3, 4, 5];
var color = ["red", "blue", "green", "yellow", "black"];
var ordinal = d3.scale.ordinal()
        .domain(index)
        .range(color);

//var circle1 = svg.append("circle")
  //      .attr("cx", 100)
    //    .attr("cy", 100)
      //  .attr("r", 45)
        //.style("fill","green");

//在1秒（1000毫秒）内将圆心坐标由100变为300
//circle1.transition()
 //   .duration(1000)
 //   .attr("cx", 300);

  
var circle1 = svg.selectAll(".MyCircle")
			.data(data1)
			.enter()
			.append("circle")
			.attr("class","MyCircle")
			.attr("cx", 50)
            .attr("cy", 90)
            .attr("r", 5)
			.transition()
			.duration(2000)
    		.ease("bounce")
   			.attr("cx", function(d,i){
			return data1time[i]*(500/12)+50})
			.attr("cy", 90)
   		    .style("fill",function(d){return ordinal(d)})
    		.attr("r", function(d,i)
			{return dataset1[i]/2});
			
var circle2 = svg.selectAll(".MyCircle2")
			.data(dataset2)
			.enter()
			.append("circle")
			.attr("class","MyCircle2")
			.attr("cx", 50)
            .attr("cy", 190)
            .attr("r", 5)
			.transition()
			.duration(3000)
    		.ease("bounce")
   			.attr("cx", function(d,i){
			return data2time[i]*(500/12)+50})
			.attr("cy", 190)
   		    .style("fill",function(d,i){return ordinal(Math.ceil(dataset2[i]/20))})
    		.attr("r", function(d,i)
			{return dataset2[i]/2});
			
var circle3 = svg.selectAll(".MyCircle3")
			.data(dataset2)
			.enter()
			.append("circle")
			.attr("class","MyCircle3")
			.attr("cx", 50)
            .attr("cy", 290)
            .attr("r", 5)
			.transition()
			.duration(4000)
    		.ease("bounce")
   			.attr("cx", function(d,i){
			return data3time[i]*(500/12)+50})
			.attr("cy", 290)
   		    .style("fill",function(d,i){return ordinal(Math.ceil(dataset3[i]/20))})
    		.attr("r", function(d,i)
			{return dataset3[i]/2});


//与第一个圆一样，省略部分代码

//在2秒（2000毫秒）内将圆心坐标由100变为300
//将颜色从绿色变为红色
//将半径从45变成25
//过渡方式采用bounce（在终点处弹跳几次

//添加文字
   var text1 =svg
        .append("text")
        .attr("class","MyText")
        .attr("transform","translate(10,57)")
        .attr("x", 1)
        .attr("y",10)
        .attr("dx",10)
        .attr("dy",30)
        .text("团队1");
	var text2 =svg
        .append("text")
        .attr("class","MyText")
        .attr("transform","translate(10,157)")
        .attr("x", 1)
        .attr("y",10)
        .attr("dx",10)
        .attr("dy",30)
        .text("团队2");
		
	var text3 =svg
        .append("text")
        .attr("class","MyText")
        .attr("transform","translate(10,257)")
        .attr("x", 1)
        .attr("y",10)
        .attr("dx",10)
        .attr("dy",30)
        .text("团队3");
	var text =svg
        .append("text")
        .attr("class","MyText2")
        .attr("transform","translate(280,0)")
        .attr("x", 1)
        .attr("y",30)
        .attr("dx",10)
        .attr("dy",0)
        .text("团队行为可视化摸型");

</script>
</p>
    <h2>二、可视化解释说明</h2>
    <p> 1、横轴表示时间轴。</p>
    <p> 2、不同颜色的圈代表不同的团队行为。</p>
    <p> 3、圈的大小表示不同的贡献程度，圈越大，贡献度越大。</p>
    <h2>三、可视化应用介绍</h2>
    <p>可视化(Visualization)是利用计算机图形学和图像处理技术，将数据转换成图形或图像在屏幕上显示出来，并进行交互处理的理论、方法和技术。它涉及到计算机图形学、图像处理、计算机视觉、计算机辅助设计等多个领域，成为研究数据表示、数据处理、决策分析等一系列问题的综合技术。目前正在飞速发展的虚拟现实技术也是以图形图像的可视化技术为依托的。 </p>
    <!-- end .content --></div>
  <div class="sidebar2">
    <h4 style="color:#FFF;background:#000" >背景</h4>
    <p style="color:#FFF;background:#000">随着媒体环境的发展变化，未来的数据新闻可视化将呈现新的态势，用户地位的转变将影响内容的生产过程，用户信息需求的多元化将会使得数据新闻可视化的个性化定制服务更加健全，在表现手段上，文字、图表、音视频，动态静态结合，手段更加多样化。数据新闻可视化设计应该更加贴近移动互联网的传播特征，符合用户的阅读体验和习惯。设计者应该转变传统媒体的思维，以用户为中心，注重用户体验，既要具有大数据思维又要有用户至上的观念。</p>
    <!-- end .sidebar2 --></div>
  <div class="footer">
    <p style="color:#FFF">此网页所有内容仅供参考，请勿移作他用。
    技术支持请联系 1018589158@qq.com。</p>
    <!-- end .footer --></div>
  <!-- end .container --></div>
</body>
</html>
